/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import * as THREE from 'three'
import React, { useRef, useEffect, useMemo} from 'react'
import { useGLTF, useScroll, ScrollControls, Scroll, PivotControls } from '@react-three/drei'
import { type GLTF } from 'three-stdlib'
import model from '/models/sku/cap_bottle.glb?url'
import { useFrame, useThree } from '@react-three/fiber'
import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';

type GLTFResult = GLTF & {
  nodes: {
    model: THREE.Mesh
  }
  materials: {
    material_0: THREE.MeshPhysicalMaterial
  }
}
function PointCloudMesh({ ...props }) {
  const scroll = useScroll()
  const { nodes, materials } = useGLTF(model) as GLTFResult
  const state = useRef<THREE.Mesh>(null)
  
  const ref = useRef()
  const lastScroll = useRef(scroll.offset);
  
  const sphereGeometry = new THREE.SphereGeometry(0.001, 6, 6);
  const sphereMaterial = new THREE.MeshBasicMaterial({
  color: 0xffa0e6
  });
  const TOTAL_POINTS = 50;

  const mesh = new THREE.Mesh(nodes.model.geometry)
  const sampler = new MeshSurfaceSampler(mesh).build();

  const pc_mesh = new THREE.InstancedMesh(sphereGeometry, sphereMaterial, TOTAL_POINTS);
  // pc_mesh.instanceMatrix.setUsage( THREE.DynamicDrawUsage )
  pc_mesh.position.set(mesh.position.x, mesh.position.y, mesh.position.z)
  pc_mesh.rotation.set(mesh.rotation.x, mesh.rotation.y, mesh.rotation.z)

  const raycaster = useMemo(() => new THREE.Raycaster(), []);
  const from = new THREE.Vector3(0, 2.4, 0);
  raycaster.near = 0.2;
  raycaster.far = 10;
  const camera = useThree((state) => state.camera)

  useEffect(() => {
    raycaster.camera = camera;
  },[raycaster, camera])
  useFrame((state, delta) => {
    if (scroll.offset !== lastScroll.current) {
      lastScroll.current = scroll.offset;
      // Place your logic here that should run only when scroll changes
      console.log('Scroll changed:', scroll.offset);
      const COUNT = Math.floor(scroll.offset * TOTAL_POINTS);
      const tempObject = new THREE.Object3D();
      const tempPosition = new THREE.Vector3();
      sampler.setWeightAttribute("position.y")
      for (let i = 0; i < TOTAL_POINTS; i++) {
        if (i > COUNT) {
          continue;
        }

        tempObject.position.set(0, 0, 0);
        sampler.sample(tempPosition);

        tempObject.position.set(tempPosition.x, tempPosition.y, tempPosition.z);
        // tempObject.scale.setScalar(Math.random() * 0.5 + 0.5);;
        tempObject.updateMatrix();

        const tempWorldPosition = new THREE.Vector3();
        tempObject.getWorldPosition(tempWorldPosition);
        tempWorldPosition.add(mesh.position);
        tempWorldPosition.applyQuaternion(mesh.quaternion);

        console.log(tempWorldPosition);
        // If the points are not on the surface
        // Use raycaster.
        const direction = from.clone().sub(tempWorldPosition).normalize();
        const geometry = new THREE.BufferGeometry();
        const positions = [
          from.x, from.y, from.z,
          tempWorldPosition.x, tempWorldPosition.y, tempWorldPosition.z
        ];
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        const colors = [
          Math.random(), Math.random(), Math.random(),
          Math.random(), Math.random(), Math.random()
        ];
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        const material = new THREE.LineBasicMaterial( { vertexColors: true } );
        const line = new THREE.Line(geometry, material);

        state.scene.add(line)

        raycaster.set(from, direction);
        const intersects = raycaster.intersectObjects(state.scene.children);
        if (intersects.length > 0 && intersects[0].distance < 1) {
          console.log(intersects)
          continue;
        }

        ref.current.setMatrixAt(i, tempObject.matrix);
        ref.current.setColorAt(i, new THREE.Color(Math.random(), Math.random(), Math.random()));
        ref.current.instanceMatrix.needsUpdate = true;
        ref.current.instanceColor.needsUpdate = true;
      }	
    }

    
  })
  return <primitive ref={ref} object={pc_mesh} {...props} dispose={null} />;
}

function PhysicalMesh({ ...props }) { 
  const scroll = useScroll()
  const ref = useRef()
  const { nodes, materials } = useGLTF(model) as GLTFResult
  useFrame((state, delta) => {
    if (ref.current) {
      ref.current.material.opacity = 1 - scroll.offset / 1.5;
      ref.current.material.transparent = true;
      ref.current.material.needsUpdate = true;
    }
  });
  return <primitive ref={ref} object={
    new THREE.Mesh(
      nodes.model.geometry,
      materials.material_0,
    )
  } {...props} dispose={null} />;
}

export function CapBottle(props: JSX.IntrinsicElements['group']) {
  

  return (
    <group {...props} dispose={null}>
      <ScrollControls damping={0.1} pages={1}>
        
        <PivotControls
          enabled={true}
          lineWidth={3}
          depthTest={true}
          displayValues={false}
          rotation={[Math.PI / 2, 0, 0]}
          opacity={0.5}
          scale={0.1}>
          <PointCloudMesh />
      <PhysicalMesh />
        </PivotControls>

      </ScrollControls>

    </group>
  )
}

useGLTF.preload(model)
